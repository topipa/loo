library(loo)
library(rstan)
options(mc.cores = 1)


context("moment matching")
set.seed(123)
S <- 40000

# helper functions for sampling from the posterior distribution
rinvchisq <- function(n, df, scale = 1/df)
{
  if ((length(scale) != 1) & (length(scale) != n))
    stop("scale should be a scalar or a vector of the same length as x")
  if (df <= 0)
    stop("df must be greater than zero")
  if (any(scale <= 0))
    stop("scale must be greater than zero")
  return((df*scale)/rchisq(n, df = df))
}

dinvchisq <- function(x, df, scale=1/df, log = FALSE)
{
  if (df <= 0)
    stop("df must be greater than zero")
  if (scale <= 0)
    stop("scale must be greater than zero")
  nu <- df/2
  if (log)
    return(ifelse(x > 0, nu*log(nu) - log(gamma(nu)) + nu*log(scale) -
                    (nu + 1)*log(x) - (nu*scale/x), NA))
  else
    return(ifelse(x > 0,
                  (((nu)^(nu))/gamma(nu)) * (scale^nu) *
                    (x^(-(nu + 1))) * exp(-nu*scale/x), NA))
}


# generate toy data
# normally distributed data with known variance
data_sd <- 1.1
data_mean <- 1.3
n <- as.integer(30)
y <- rnorm(n = n, mean = data_mean, sd = data_sd)
y_tilde <- 11
y[1] <- y_tilde

ymean <- mean(y)
s2 <- sum((y - ymean)^2)/(n - 1)

# draws from the posterior distribution when including all observations
draws_full_posterior_sigma2 <- rinvchisq(S, n - 1, s2)
draws_full_posterior_mu <- rnorm(S, ymean, sqrt(draws_full_posterior_sigma2/n))


# create a dummy model object
x <- list()
x$data <- list()
x$data$y <- y
x$data$n <- n
x$data$ymean <- ymean
x$data$s2 <- s2

x$draws <- data.frame(
  mu = draws_full_posterior_mu,
  sigma = sqrt(draws_full_posterior_sigma2)
)








# implement functions for moment matching loo


# extract original posterior draws
post_draws_test <- function(x) {
  as.matrix(x$draws)
}

# extract original log lik draws
log_lik_test <- function(x, i) {
  -0.5*log(2*pi) - log(x$draws$sigma) - 1.0/(2*x$draws$sigma^2)*(x$data$y[i] - x$draws$mu)^2
}


loglik <- matrix(0,S,n)
for (j in seq(n)) {
  loglik[,j] <- log_lik_test(x, j)
}



# mu, log(sigma)
unconstrain_pars_test <- function(x, pars) {
  upars <- as.matrix(pars)
  upars[,2] <- log(upars[,2])
  upars
}

log_prob_upars_test <- function(x, upars) {
  dinvchisq(exp(upars[,2])^2,x$data$n - 1,x$data$s2, log = TRUE) + dnorm(upars[,1],x$data$ymean,exp(upars[,2])/sqrt(x$data$n), log = TRUE)
}

# compute log_lik values based on the unconstrained parameters
log_lik_upars_test <- function(x, upars, i) {
  -0.5*log(2*pi) - upars[,2] - 1.0/(2*exp(upars[,2])^2)*(x$data$y[i] - upars[,1])^2
}



upars <- unconstrain_pars_test(x, x$draws)
lwi_1 <- -loglik[,1]
lwi_1 <- lwi_1 - logSumExp(lwi_1)



test_that("log_prob_upars_test works", {
  upars <- unconstrain_pars_test(x, x$draws)
  xloo <- list()
  xloo$data <- list()
  xloo$data$y <- y[-1]
  xloo$data$n <- n - 1
  xloo$data$ymean <- mean(y[-1])
  xloo$data$s2 <- sum((y[-1] - mean(y[-1]))^2)/(n - 2)

  post1 <- log_prob_upars_test(x,upars)
  post1 <- post1 - logSumExp(post1)
  post2 <- log_prob_upars_test(xloo,upars) + loglik[,1]
  post2 <- post2 - logSumExp(post2)
  expect_equal(post1,post2)
})


test_that("mmloo_manual warnings work", {
  # loo object
  loo_manual <- suppressWarnings(loo(loglik))


  expect_warning(mmloo(x, loo_manual, post_draws_test, log_lik_test,
                              unconstrain_pars_test, log_prob_upars_test,
                              log_lik_upars_test, max_iters = 30L,
                              k_thres = 100, split = FALSE,
                              cov = TRUE, cores = 1), "Some Pareto k")

  expect_warning(mmloo(x, loo_manual, post_draws_test, log_lik_test,
                              unconstrain_pars_test, log_prob_upars_test,
                              log_lik_upars_test, max_iters = 30L,
                              k_thres = 0.5, split = FALSE,
                              cov = TRUE, cores = 1), "The accuracy of self-normalized importance sampling")

  expect_warning(mmloo(x, loo_manual, post_draws_test, log_lik_test,
                              unconstrain_pars_test, log_prob_upars_test,
                              log_lik_upars_test, max_iters = 2,
                              k_thres = 0.5, split = TRUE,
                              cov = TRUE, cores = 1), "The maximum number of moment matching iterations")
})


test_that("mmloo_manual works", {

  # loo object
  loo_manual <- suppressWarnings(loo(loglik))

  mmloo_object <- suppressWarnings(mmloo(x, loo_manual, post_draws_test, log_lik_test,
                                                unconstrain_pars_test, log_prob_upars_test,
                                                log_lik_upars_test, max_iters = 30L,
                                                k_thres = 0.8, split = FALSE,
                                                cov = TRUE, cores = 1))

  expect_equal_to_reference(mmloo_object, "reference-results/moment_match_loo_1.rds")

  mmloo_object2 <- suppressWarnings(mmloo(x, loo_manual, post_draws_test, log_lik_test,
                                                unconstrain_pars_test, log_prob_upars_test,
                                                log_lik_upars_test, max_iters = 30L,
                                                k_thres = 0.5, split = FALSE,
                                                cov = TRUE, cores = 1))

  expect_equal_to_reference(mmloo_object2, "reference-results/moment_match_loo_2.rds")

  mmloo_object3 <- suppressWarnings(mmloo(x, loo_manual, post_draws_test, log_lik_test,
                                                unconstrain_pars_test, log_prob_upars_test,
                                                log_lik_upars_test, max_iters = 30L,
                                                k_thres = 0.5, split = TRUE,
                                                cov = TRUE, cores = 1))

  expect_equal_to_reference(mmloo_object3, "reference-results/moment_match_loo_3.rds")

  mmloo_object4 <- suppressWarnings(mmloo(x, loo_manual, post_draws_test, log_lik_test,
                                                unconstrain_pars_test, log_prob_upars_test,
                                                log_lik_upars_test, max_iters = 30L,
                                                k_thres = 100, split = FALSE,
                                                cov = TRUE, cores = 1))

  expect_equal(loo_manual,mmloo_object4)

})



test_that("mmloo_manual works with multiple cores", {

  # loo object
  loo_manual <- suppressWarnings(loo(loglik))

  mmloo_manual3 <- suppressWarnings(mmloo(x, loo_manual, post_draws_test, log_lik_test,
                                                 unconstrain_pars_test, log_prob_upars_test,
                                                 log_lik_upars_test, max_iters = 30L,
                                                 k_thres = 0.5, split = FALSE,
                                                 cov = TRUE, cores = 1))

  mmloo_manual4 <- suppressWarnings(mmloo(x, loo_manual, post_draws_test, log_lik_test,
                                                 unconstrain_pars_test, log_prob_upars_test,
                                                 log_lik_upars_test, max_iters = 30L,
                                                 k_thres = 0.5, split = FALSE,
                                                 cov = TRUE, cores = 4))

  expect_equal(mmloo_manual3$diagnostics$pareto_k, mmloo_manual4$diagnostics$pareto_k)
  expect_equal(mmloo_manual3$diagnostics$n_eff, mmloo_manual4$diagnostics$n_eff)

  expect_equal(mmloo_manual3$estimates, mmloo_manual4$estimates)

  # TODO
  # this test fails because mcse_elpd_loo computation has randomness
  # fix this when issue #116 is fixed
  # expect_equal(mmloo_manual3$pointwise, mmloo_manual4$pointwise)

})



test_that("split_mm works", {

  psis_1 <- suppressWarnings(loo::psis(lwi_1 - max(lwi_1), r_eff = 1, cores = 1))
  lwi_1_ps <- as.vector(weights(psis_1))

  split <- split_mm(
    x, upars, cov = FALSE, total_shift = c(0,0), total_scaling = c(1,1), total_mapping = diag(c(1,1)), i = 1,
    log_prob_upars = log_prob_upars_test, log_lik_upars = log_lik_upars_test,
    cores = cores, r_effi = 1)

  expect_named(split,c("lwi", "log_liki"))

  expect_equal(lwi_1_ps,split$lwi)

  split2 <- split_mm(
    x, upars, cov = FALSE, total_shift = c(-0.1,-0.2), total_scaling = c(0.7,0.7),
    total_mapping = matrix(c(1,0.1,0.1,1),2,2), i = 1,
    log_prob_upars = log_prob_upars_test, log_lik_upars = log_lik_upars_test,
    cores = cores, r_effi = 1)

  expect_equal_to_reference(split2, "reference-results/moment_match_split.rds")

})

test_that("Difficult Stan model works", {

  model_code <- "data {
  int<lower=0> N;
  int<lower=0> K;
  matrix[N, K] x;
  vector[N] y;
  real<lower=0> beta_prior_scale;
  real<lower=0> alpha_prior_scale;

}
  parameters {
  real alpha;
  vector[K] beta;
  real<lower=0> sigma; // error scale
  }
  model {
  y ~ normal(x * beta + alpha, sigma); // likelihood
  beta ~ normal(0,beta_prior_scale);
  alpha ~ normal(0,alpha_prior_scale);
  sigma ~ exponential(1);
  }
  generated quantities {
  vector[N] log_lik;
  for (n in 1:N)
  log_lik[n] = normal_lpdf(y[n] | x[n] * beta + alpha, sigma);
  }


  "

  normalize_matrix <- function(a) {
    b = sweep(a,MARGIN = 2,(apply(a,MARGIN = 2,FUN = mean)),`-`)
    return(sweep(b,MARGIN = 2,(apply(b,MARGIN = 2,FUN = sd)),`/`))
  }

  normalize_vector <- function(a) {
    b = a - mean(a)
    return(b/sd(b))
  }


  SEED = 1234
  set.seed(SEED)

  # generate data
  n = as.integer(60)
  k = as.integer(50)
  rho <- 0.8
  Sigma <- rho*array(1, c(k,k)) + (1 - rho)*diag(k)
  x <- MASS::mvrnorm(n, rep(0,k), Sigma)
  w <- c(c(-1, 1, 2), rep(0,k - 3))
  y <- x %*% w + rnorm(n)*2

  y = normalize_vector(y)
  x = normalize_matrix(x)


  beta_prior_scale = 2.5
  alpha_prior_scale = 5.0

  stanmodel = stan_model(model_code = model_code)
  standata = list(N = n, K = k, x = as.matrix(x), y = c(y),beta_prior_scale = beta_prior_scale, alpha_prior_scale = alpha_prior_scale)



  fit <- suppressWarnings(sampling(stanmodel,standata, chains = 1))

  loo2 <- suppressWarnings(loo(fit,moment_match = TRUE))

  expect_equal_to_reference(loo2, "reference-results/moment_match_loo_Stan_1.rds")







})
